import org.marc4j.marc.DataField;
import org.marc4j.marc.Record;
import org.marc4j.marc.Subfield;

import java.util.LinkedHashSet;
import java.util.regex.*;


class ContainerIdAndTitle {
    private String id_;
    private String title_;

    public ContainerIdAndTitle(String id, String title) {
	this.id_ = id;
	this.title_ = title;
    }

    public String getId() { return id_; }
    public String getTitle() { return title_; }
}


/**
 * Returns either a Set<String> of parent IDs or parent titles.  Only IDs or titles will be returned if the
 * corresponding "partner" also exists.  Singleton occurrences of IDs or titles will be skipped and warnings will
 * be written to stderr.
 * @arg   selector                        Must be either "ids" or "titles".
 * @arg   fields_and_subfields            fields_and_subfields, a colon-separated "list" of field tags where each
 *                                        tag must be followed by two subfield codes e.g. "800aw:810aw:830aw".
 *                                        The first subfield code for each tag must indicate the "title" subfield
 *                                        and the second subfield code the ID subfield.
 * @arg   optional_id_prefix              If non-empty, this String will prepended to each ID before it is being
 *                                        returned.
 * @arg   optional_field_extraction_regex 
 * @return                                "null" if no container ID and title pairs were found, otherwise if
 *                                        "selector" was "ids" a Set<String> containing the IDs will be returned,
 *                                        if "selector" was "titles", a a Set<String> containing the titles will
 *                                        be returned.
 */
public Set getContainerIdsOrTitles(Record record, String selector, String fields_and_subfields,
				   String optional_id_prefix, String optional_field_extraction_regex) {
    if (!selector.equals("ids") && !selector.equals("titles")) {
	System.err.println("in getContainerIdsOrTitles(): selector (" + selector
			   + ") must be \"ids\" or \"titles\"!");
	System.exit(-1);
    }

    String[] fields_and_subfields_array = fields_and_subfields.split(":");
    if (fields_and_subfields_array.length == 0) {
	System.err.println("in getContainerIdsOrTitles(): missing fields and subfields to select!");
	System.exit(-2);
    }

    Pattern extraction_pattern = null;
    if (!optional_field_extraction_regex.isEmpty())
	extraction_pattern = Pattern.compile(optional_field_extraction_regex);

    Set container_ids_and_titles = new LinkedHashSet();
    for (int i = 0; i < fields_and_subfields_array.length; ++i) {
	char title_subfield_code = fields_and_subfields_array[i].charAt(3);
	char id_subfield_code = fields_and_subfields_array[i].charAt(4);
	for (DataField field : record.getVariableFields(fields_and_subfields_array[i].substring(0, 3))) {
	    List title_subfields = field.getSubfields(title_subfield_code);
	    List id_subfields = field.getSubfields(id_subfield_code);

	    int title_subfield_size = title_subfields.size();
	    int id_subfield_size = id_subfields.size();
	    if (title_subfield_size !=  id_subfield_size) {
		System.err.println("Warning: in getContainerIdsOrTitles(): size # of title subfields ("
				   + title_subfield_size + ") != # of id subfields (" + id_subfield_size + ")!");
		continue;
	    }

	    Iterator id_iter = field.getSubfields(id_subfield_code).iterator();
	    Iterator title_iter = field.getSubfields(title_subfield_code).iterator();
	    while (id_iter.hasNext()) {
		String parent_ref = id_iter.next().getData();

		if (extraction_pattern != null) {
		    Matcher matcher = extraction_pattern.matcher(parent_ref);
		    if (!matcher.matches()) {
			System.err.println("in getContainerIdsOrTitles() in multi_part.bsh: parent ID \"" + parent_ref
					   + "\"did not match the pattern \"" + extraction_pattern.pattern() + "\"!");
			title_iter.next();
			continue;
		    }

		    parent_ref = matcher.group(1);
		}

		String parent_id;
		if (optional_id_prefix == null)
		    parent_id = parent_ref;
		else
		    parent_id = optional_id_prefix + parent_ref;

		container_ids_and_titles.add(new ContainerIdAndTitle(parent_id, title_iter.next().getData()));
	    }
	}
    }

    if (container_ids_and_titles.isEmpty())
	return null;

    LinkedHashSet ret_vals = new LinkedHashSet();
    for (ContainerIdAndTitle id_and_title : container_ids_and_titles) {
	if (selector.equals("id"))
	    ret_vals.add(id_and_title.getId());
	else
	    ret_vals.add(id_and_title.getTitle());
    }

    return ret_vals;
}
